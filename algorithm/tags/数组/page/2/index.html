<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-tags-post-list-page plugin-blog plugin-id-algorithm">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">71 篇博文 含有标签「数组」 | D9笔记</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://whilconn.github.io/algorithm/tags/数组/page/2/"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="71 篇博文 含有标签「数组」 | D9笔记"><meta data-rh="true" name="docusaurus_tag" content="blog_tags_posts"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_tags_posts"><link data-rh="true" rel="icon" href="/img/avatar.png"><link data-rh="true" rel="canonical" href="https://whilconn.github.io/algorithm/tags/数组/page/2/"><link data-rh="true" rel="alternate" href="https://whilconn.github.io/algorithm/tags/数组/page/2/" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://whilconn.github.io/algorithm/tags/数组/page/2/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="D9笔记 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="D9笔记 Atom Feed">



<link rel="alternate" type="application/rss+xml" href="/algorithm/rss.xml" title="D9笔记 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/algorithm/atom.xml" title="D9笔记 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.c670e1bb.css">
<link rel="preload" href="/assets/js/runtime~main.b2c3c553.js" as="script">
<link rel="preload" href="/assets/js/main.8c1187cf.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent__EBl" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav class="navbar navbar--fixed-top navbarHideable_wgfI"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/avatar.png" alt="D9笔记" class="themedImage_Ma8U themedImage--light_bRiH"><img src="/img/avatar.png" alt="D9笔记" class="themedImage_Ma8U themedImage--dark_FGN8"></div><b class="navbar__title text--truncate">D9笔记</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/portals/">导航</a><a class="navbar__item navbar__link" href="/blog/">博客</a><a class="navbar__item navbar__link" href="/algorithm/archive/">算法题解</a><div class="toggle_aJXW colorModeToggle_jjVx"><button class="clean-btn toggleButton_GOfG toggleButtonDisabled_hrwL" type="button" disabled="" title="切换浅色/暗黑模式（当前为暗黑模式）" aria-label="切换浅色/暗黑模式（当前为暗黑模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_XjdL"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_dbHk"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_iFVH"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_gmiV"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_JwN5 thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_J0Oq margin-bottom--md">最新文章</div><ul class="sidebarItemList_xZD3 clean-list"><li class="sidebarItem_nkfF"><a class="sidebarItemLink_FDAB" href="/algorithm/2293.极大极小游戏/">2293.极大极小游戏</a></li><li class="sidebarItem_nkfF"><a class="sidebarItemLink_FDAB" href="/algorithm/1819.序列中不同最大公约数的数目/">1819.序列中不同最大公约数的数目</a></li><li class="sidebarItem_nkfF"><a class="sidebarItemLink_FDAB" href="/algorithm/2287.重排字符形成目标字符串/">2287.重排字符形成目标字符串</a></li><li class="sidebarItem_nkfF"><a class="sidebarItemLink_FDAB" href="/algorithm/1807.替换字符串中的括号内容/">1807.替换字符串中的括号内容</a></li><li class="sidebarItem_nkfF"><a class="sidebarItemLink_FDAB" href="/algorithm/2283.判断一个数的数字计数是否等于数位的值/">2283.判断一个数的数字计数是否等于数位的值</a></li><li class="sidebarItem_nkfF"><a class="sidebarItemLink_FDAB" href="/algorithm/753.破解保险箱/">753.破解保险箱</a></li><li class="sidebarItem_nkfF"><a class="sidebarItemLink_FDAB" href="/algorithm/1806.还原排列的最少操作步数/">1806.还原排列的最少操作步数</a></li><li class="sidebarItem_nkfF"><a class="sidebarItemLink_FDAB" href="/algorithm/2185.统计包含给定前缀的字符串/">2185.统计包含给定前缀的字符串</a></li><li class="sidebarItem_nkfF"><a class="sidebarItemLink_FDAB" href="/algorithm/1658.将 x 减到 0 的最小操作数/">1658.将 x 减到 0 的最小操作数</a></li><li class="sidebarItem_nkfF"><a class="sidebarItemLink_FDAB" href="/algorithm/2180.统计各位数字之和为偶数的整数个数/">2180.统计各位数字之和为偶数的整数个数</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><header class="margin-bottom--xl"><h1>71 篇博文 含有标签「数组」</h1><a href="/algorithm/tags/">查看所有标签</a></header><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_mBgL" itemprop="headline"><a itemprop="url" href="/algorithm/1277.统计全为 1 的正方形子矩阵/">1277.统计全为 1 的正方形子矩阵</a></h2><div class="container_hz_z margin-vert--md"><time datetime="2022-12-08T00:00:00.000Z" itemprop="datePublished">2022年12月8日</time> · <!-- -->阅读需 3 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_uuk1"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="1题干">1、题干<a class="hash-link" href="#1题干" title="标题的直接链接">​</a></h2><p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> matrix =<br>
<!-- -->[<br>
  <!-- -->[<!-- -->0,1,1,1<!-- -->]<!-- -->,<br>
  <!-- -->[<!-- -->1,1,1,1<!-- -->]<!-- -->,<br>
  <!-- -->[<!-- -->0,1,1,1<!-- -->]<br>
<!-- -->]<br>
<strong>输出：</strong> 15<br>
<strong>解释：</strong>  <br>
边长为 1 的正方形有 <strong>10</strong> 个。<br>
边长为 2 的正方形有 <strong>4</strong> 个。<br>
边长为 3 的正方形有 <strong>1</strong> 个。<br>
正方形的总数 = 10 + 4 + 1 = <strong>15</strong>.<br></p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> matrix = <br>
<!-- -->[<br>
<!-- -->[<!-- -->1,0,1<!-- -->]<!-- -->,<br>
<!-- -->[<!-- -->1,1,0<!-- -->]<!-- -->,<br>
<!-- -->[<!-- -->1,1,0<!-- -->]<br>
<!-- -->]<br>
<strong>输出：</strong> 7<br>
<strong>解释：</strong> <br>
边长为 1 的正方形有 <strong>6</strong> 个。 <br>
边长为 2 的正方形有 <strong>1</strong> 个。<br>
正方形的总数 = 6 + 1 = <strong>7</strong>.<br></p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 300</code></li><li><code>1 &lt;= arr[0].length &lt;= 300</code></li><li><code>0 &lt;= arr[i][j] &lt;= 1</code></li></ul><blockquote><p>Problem: <a href="https://leetcode.cn/problems/count-square-submatrices-with-all-ones/description/" target="_blank" rel="noopener noreferrer">1277. 统计全为 1 的正方形子矩阵</a></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="2方法1">2、方法1<a class="hash-link" href="#2方法1" title="标题的直接链接">​</a></h2><p>前缀和+暴力枚举</p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="3code">3、Code<a class="hash-link" href="#3code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function countSquares(matrix: number[][]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const preSum = matrix.map(m =&gt; m.map(() =&gt; 0));</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; matrix.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let sumRow = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (let j = 0; j &lt; matrix[0].length; j++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            sumRow += matrix[i][j];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            preSum[i][j] = sumRow + (i ? preSum[i - 1][j] : 0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let ans = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; matrix.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (let j = 0; j &lt; matrix[0].length; j++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            for (let k = 1; k &lt;= j + 1; k++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                const sr = i - k &gt; -1 ? preSum[i - k][j] : 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                const sc = preSum[i][j - k] || 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                const src = i - k &gt; -1 &amp;&amp; j - k &gt; -1 ? preSum[i - k][j - k] : 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                const s = preSum[i][j] - sr - sc + src;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                if (s !== k ** 2) break;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                ans++;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return ans;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="4复杂度">4、复杂度<a class="hash-link" href="#4复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(n^3)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="5执行结果">5、执行结果<a class="hash-link" href="#5执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1670469669-gxhwab-image.png" alt="image.png" class="img_jWLO"></p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="6方法2">6、方法2<a class="hash-link" href="#6方法2" title="标题的直接链接">​</a></h2><p>动态规划</p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="7code">7、Code<a class="hash-link" href="#7code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function countSquares(matrix: number[][]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let ans = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; matrix.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (let j = 0; j &lt; matrix[0].length; j++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if (i &amp;&amp; j &amp;&amp; matrix[i][j]) matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j], matrix[i - 1][j - 1]) + 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            ans += matrix[i][j];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return ans;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="8复杂度">8、复杂度<a class="hash-link" href="#8复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="9执行结果">9、执行结果<a class="hash-link" href="#9执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1670469590-JoBuwW-image.png" alt="image.png" class="img_jWLO"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_zFUd padding--none margin-left--sm"><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数组/">数组</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/动态规划/">动态规划</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/矩阵/">矩阵</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_mBgL" itemprop="headline"><a itemprop="url" href="/algorithm/1775.通过最少操作次数使数组的和相等/">1775.通过最少操作次数使数组的和相等</a></h2><div class="container_hz_z margin-vert--md"><time datetime="2022-12-07T00:00:00.000Z" itemprop="datePublished">2022年12月7日</time> · <!-- -->阅读需 4 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_uuk1"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="1题干">1、题干<a class="hash-link" href="#1题干" title="标题的直接链接">​</a></h2><p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 <code>1</code> 和 <code>6</code>）。</p><p>每次操作中，你可以选择 <strong>任意</strong> 数组中的任意一个整数，将它变成 <code>1</code> 到 <code>6</code> 之间 <strong>任意</strong> 的值（包含 <code>1</code> 和 <code>6</code>）。</p><p>请你返回使 <code>nums1</code> 中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> nums1 = <!-- -->[<!-- -->1,2,3,4,5,6<!-- -->]<!-- -->, nums2 = <!-- -->[<!-- -->1,1,2,2,2,2<!-- -->]<br>
<strong>输出：</strong> 3<br>
<strong>解释：</strong> 你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。<br></p><ul><li>将 nums2<!-- -->[<!-- -->0<!-- -->]<!-- --> 变为 6 。 nums1 = <!-- -->[<!-- -->1,2,3,4,5,6<!-- -->]<!-- -->, nums2 = <!-- -->[<strong>6</strong>,1,2,2,2,2<!-- -->]<!-- --> 。<br></li><li>将 nums1<!-- -->[<!-- -->5<!-- -->]<!-- --> 变为 1 。 nums1 = <!-- -->[<!-- -->1,2,3,4,5,<strong>1</strong>]<!-- -->, nums2 = <!-- -->[<!-- -->6,1,2,2,2,2<!-- -->]<!-- --> 。<br></li><li>将 nums1<!-- -->[<!-- -->2<!-- -->]<!-- --> 变为 2 。 nums1 = <!-- -->[<!-- -->1,2,<strong>2</strong>,4,5,1<!-- -->]<!-- -->, nums2 = <!-- -->[<!-- -->6,1,2,2,2,2<!-- -->]<!-- --> 。<br></li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> nums1 = <!-- -->[<!-- -->1,1,1,1,1,1,1<!-- -->]<!-- -->, nums2 = <!-- -->[<!-- -->6<!-- -->]<br>
<strong>输出：</strong> <!-- -->-<!-- -->1<br>
<strong>解释：</strong> 没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。<br></p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> nums1 = <!-- -->[<!-- -->6,6<!-- -->]<!-- -->, nums2 = <!-- -->[<!-- -->1<!-- -->]<br>
<strong>输出：</strong> 3<br>
<strong>解释：</strong> 你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。<br></p><ul><li>将 nums1<!-- -->[<!-- -->0<!-- -->]<!-- --> 变为 2 。 nums1 = <!-- -->[<strong>2</strong>,6<!-- -->]<!-- -->, nums2 = <!-- -->[<!-- -->1<!-- -->]<!-- --> 。<br></li><li>将 nums1<!-- -->[<!-- -->1<!-- -->]<!-- --> 变为 2 。 nums1 = <!-- -->[<!-- -->2,<strong>2</strong>]<!-- -->, nums2 = <!-- -->[<!-- -->1<!-- -->]<!-- --> 。<br></li><li>将 nums2<!-- -->[<!-- -->0<!-- -->]<!-- --> 变为 4 。 nums1 = <!-- -->[<!-- -->2,2<!-- -->]<!-- -->, nums2 = <!-- -->[<strong>4</strong>]<!-- --> 。<br></li></ul></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 10^5</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li></ul><blockquote><p>Problem: <a href="https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/description/" target="_blank" rel="noopener noreferrer">1775. 通过最少操作次数使数组的和相等</a></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="2思路">2、思路<a class="hash-link" href="#2思路" title="标题的直接链接">​</a></h2><p>题目要求使数组的和相等的最少操作次数，可以使用贪心算法。假设 <code>nums1</code> 的和较小，升序地将 <code>nums1</code> 中的数尽量变大（最大为 <code>6</code>），降序地将 <code>nums2</code> 中的数尽量变小（最小为 <code>1</code>），直到两个数组的和相等。</p><p>操作时需要同时处理 <code>nums1</code> 中的数 <code>n</code> 和 <code>nums2</code> 中的数 <code>7-n</code>。</p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="3code">3、Code<a class="hash-link" href="#3code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function minOperations(nums1: number[], nums2: number[]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const n1 = nums1.length, n2 = nums2.length;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if (n1 &lt; n2 &amp;&amp; 6 * n1 &lt; n2 || (n2 &lt; n1 &amp;&amp; 6 * n2 &lt; n1)) return -1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let sum1 = nums1.reduce((a, c) =&gt; a + c, 0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let sum2 = nums2.reduce((a, c) =&gt; a + c, 0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if (sum1 === sum2) return 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if (sum1 &gt; sum2) [sum1, sum2, nums1, nums2] = [sum2, sum1, nums2, nums1];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const diffList = new Array(6).fill(0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; Math.max(n1, n2); i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (nums1[i]) diffList[6 - nums1[i]] += 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (nums2[i]) diffList[nums2[i] - 1] += 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let ans = 0, diff = sum2 - sum1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let d = 5; d &gt; 0 &amp;&amp; diff &gt; 0; d--) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        const u = Math.min(diffList[d], Math.ceil(diff / d));</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        diff -= d * u;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        ans += u;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return ans;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="4复杂度">4、复杂度<a class="hash-link" href="#4复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="5执行结果">5、执行结果<a class="hash-link" href="#5执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1670395086-ugSPIN-image.png" alt="image.png" class="img_jWLO"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_zFUd padding--none margin-left--sm"><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/贪心/">贪心</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数组/">数组</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/哈希表/">哈希表</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/计数/">计数</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_mBgL" itemprop="headline"><a itemprop="url" href="/algorithm/1774.最接近目标价格的甜点成本/">1774.最接近目标价格的甜点成本</a></h2><div class="container_hz_z margin-vert--md"><time datetime="2022-12-04T00:00:00.000Z" itemprop="datePublished">2022年12月4日</time> · <!-- -->阅读需 4 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_uuk1"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="1题干">1、题干<a class="hash-link" href="#1题干" title="标题的直接链接">​</a></h2><p>你打算做甜点，现在需要购买配料。目前共有 <code>n</code> 种冰激凌基料和 <code>m</code> 种配料可供选购。而制作甜点需要遵循以下几条规则：</p><ul><li>必须选择 <strong>一种</strong> 冰激凌基料。</li><li>可以添加 <strong>一种或多种</strong> 配料，也可以不添加任何配料。</li><li>每种类型的配料 <strong>最多两份</strong> 。</li></ul><p>给你以下三个输入：</p><ul><li><code>baseCosts</code> ，一个长度为 <code>n</code> 的整数数组，其中每个 <code>baseCosts[i]</code> 表示第 <code>i</code> 种冰激凌基料的价格。</li><li><code>toppingCosts</code>，一个长度为 <code>m</code> 的整数数组，其中每个 <code>toppingCosts[i]</code> 表示 <strong>一份</strong> 第 <code>i</code> 种冰激凌配料的价格。</li><li><code>target</code> ，一个整数，表示你制作甜点的目标价格。</li></ul><p>你希望自己做的甜点总成本尽可能接近目标价格 <code>target</code> 。</p><p>返回最接近 <code>target</code> 的甜点成本。如果有多种方案，返回 <strong>成本相对较低</strong> 的一种。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> baseCosts = <!-- -->[<!-- -->1,7<!-- -->]<!-- -->, toppingCosts = <!-- -->[<!-- -->3,4<!-- -->]<!-- -->, target = 10<br>
<strong>输出：</strong> 10<br>
<strong>解释：</strong> 考虑下面的方案组合（所有下标均从 0 开始）：<br></p><ul><li>选择 1 号基料：成本 7<br></li><li>选择 1 份 0 号配料：成本 1 x 3 = 3<br></li><li>选择 0 份 1 号配料：成本 0 x 4 = 0<br>
总成本：7 + 3 + 0 = 10 。<br></li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> baseCosts = <!-- -->[<!-- -->2,3<!-- -->]<!-- -->, toppingCosts = <!-- -->[<!-- -->4,5,100<!-- -->]<!-- -->, target = 18<br>
<strong>输出：</strong> 17<br>
<strong>解释：</strong> 考虑下面的方案组合（所有下标均从 0 开始）：<br></p><ul><li>选择 1 号基料：成本 3<br></li><li>选择 1 份 0 号配料：成本 1 x 4 = 4<br></li><li>选择 2 份 1 号配料：成本 2 x 5 = 10<br></li><li>选择 0 份 2 号配料：成本 0 x 100 = 0<br>
总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。<br></li></ul></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> baseCosts = <!-- -->[<!-- -->3,10<!-- -->]<!-- -->, toppingCosts = <!-- -->[<!-- -->2,5<!-- -->]<!-- -->, target = 9<br>
<strong>输出：</strong> 8<br>
<strong>解释：</strong> 可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。<br></p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong> baseCosts = <!-- -->[<!-- -->10<!-- -->]<!-- -->, toppingCosts = <!-- -->[<!-- -->1<!-- -->]<!-- -->, target = 1<br>
<strong>输出：</strong> 10<br>
<strong>解释：</strong> 注意，你可以选择不添加任何配料，但你必须选择一种基料。<br></p></blockquote><p><strong>提示：</strong></p><ul><li><code>n == baseCosts.length</code></li><li><code>m == toppingCosts.length</code></li><li><code>1 &lt;= n, m &lt;= 10</code></li><li><code>1 &lt;= baseCosts[i], toppingCosts[i] &lt;= 10^4</code></li><li><code>1 &lt;= target &lt;= 10^4</code></li></ul><blockquote><p>Problem: <a href="https://leetcode.cn/problems/closest-dessert-cost/description/" target="_blank" rel="noopener noreferrer">1774. 最接近目标价格的甜点成本</a></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="2思路">2、思路<a class="hash-link" href="#2思路" title="标题的直接链接">​</a></h2><p>暴力搜索，确定基料，枚举配料</p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="3code">3、Code<a class="hash-link" href="#3code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function closestCost(baseCosts: number[], toppingCosts: number[], target: number): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let ans = baseCosts[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    function dfs(c: number, ti: number) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (c === target) return ans = target;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        else {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            const d1 = Math.abs(c - target), d2 = Math.abs(ans - target);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if (d1 &lt; d2 || (d1 === d2 &amp;&amp; c &lt; ans)) ans = c;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (let i = ti; i &lt; toppingCosts.length &amp;&amp; c &lt;= target; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            for (let k = 0; k &lt; 3; k++) dfs(c + k * toppingCosts[i], i + 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (const b of baseCosts) dfs(b, 0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return ans;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="4执行结果">4、执行结果<a class="hash-link" href="#4执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1670132640-tlPgXU-image.png" alt="image.png" class="img_jWLO"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_zFUd padding--none margin-left--sm"><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数组/">数组</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/动态规划/">动态规划</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/回溯/">回溯</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_mBgL" itemprop="headline"><a itemprop="url" href="/algorithm/1769.移动所有球到每个盒子所需的最小操作数/">1769.移动所有球到每个盒子所需的最小操作数</a></h2><div class="container_hz_z margin-vert--md"><time datetime="2022-12-02T00:00:00.000Z" itemprop="datePublished">2022年12月2日</time> · <!-- -->阅读需 4 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_uuk1"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="1题干">1、题干<a class="hash-link" href="#1题干" title="标题的直接链接">​</a></h2><p>有 <code>n</code> 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code> ，其中 <code>boxes[i]</code> 的值为 <code>&#x27;0&#x27;</code> 表示第 <code>i</code> 个盒子是 <strong>空</strong> 的，而 <code>boxes[i]</code> 的值为 <code>&#x27;1&#x27;</code> 表示盒子里有 <strong>一个</strong> 小球。</p><p>在一步操作中，你可以将 <strong>一个</strong> 小球从某个盒子移动到一个与之相邻的盒子中。第 <code>i</code> 个盒子和第 <code>j</code> 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p><p>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 <strong>最小</strong> 操作数。</p><p>每个 <code>answer[i]</code> 都需要根据盒子的 <strong>初始状态</strong> 进行计算。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> boxes = &quot;110&quot;<br>
<strong>输出：</strong> <!-- -->[<!-- -->1,1,3<!-- -->]<br>
<strong>解释：</strong> 每个盒子对应的最小操作数如下：<br>
1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。<br>
2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。<br>
3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。<br></p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> boxes = &quot;001011&quot;<br>
<strong>输出：</strong> <!-- -->[<!-- -->11,8,5,4,3,4<!-- -->]<br></p></blockquote><p><strong>提示：</strong></p><ul><li><code>n == boxes.length</code></li><li><code>1 &lt;= n &lt;= 2000</code></li><li><code>boxes[i]</code> 为 <code>&#x27;0&#x27;</code> 或 <code>&#x27;1&#x27;</code></li></ul><blockquote><p>Problem: <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/description/" target="_blank" rel="noopener noreferrer">1769. 移动所有球到每个盒子所需的最小操作数</a></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="2思路1">2、思路1<a class="hash-link" href="#2思路1" title="标题的直接链接">​</a></h2><p>双层循环暴力枚举</p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="3code">3、Code<a class="hash-link" href="#3code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function minOperations(boxes: string): number[] {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const ans = new Array(boxes.length).fill(0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; ans.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (let j = 0; j &lt; boxes.length; j++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if (boxes[j] === &#x27;1&#x27;) ans[i] += Math.abs(i - j);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return ans;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="4复杂度">4、复杂度<a class="hash-link" href="#4复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="5执行结果">5、执行结果<a class="hash-link" href="#5执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1669949416-pqDcIn-image.png" alt="image.png" class="img_jWLO"></p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="6思路2">6、思路2<a class="hash-link" href="#6思路2" title="标题的直接链接">​</a></h2><p>单层循环累加左右步数</p><p>关键点：左半边有 <code>lc</code> 个 <code>1</code> 时，每移动一次左半边步数 <code>ls</code> 需累加 <code>lc</code>，同理右半边步数 <code>rs</code> 需减去 <code>rc</code></p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="7code">7、Code<a class="hash-link" href="#7code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function minOperations(boxes: string): number[] {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let rc = 0, rs = 0, lc = 0, ls = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const ans = new Array(boxes.length).fill(0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; boxes.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (boxes[i] === &#x27;1&#x27;) rc += 1, rs += i;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; ans.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        ans[i] = ls + rs;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (boxes[i] === &#x27;1&#x27;) rc--, lc++;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        rs -= rc, ls += lc;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return ans;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="8复杂度">8、复杂度<a class="hash-link" href="#8复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="9执行结果">9、执行结果<a class="hash-link" href="#9执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1669949440-bhpOWf-image.png" alt="image.png" class="img_jWLO"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_zFUd padding--none margin-left--sm"><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数组/">数组</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/字符串/">字符串</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_mBgL" itemprop="headline"><a itemprop="url" href="/algorithm/809.情感丰富的文字/">809.情感丰富的文字</a></h2><div class="container_hz_z margin-vert--md"><time datetime="2022-11-25T00:00:00.000Z" itemprop="datePublished">2022年11月25日</time> · <!-- -->阅读需 3 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_uuk1"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="1题干">1、题干<a class="hash-link" href="#1题干" title="标题的直接链接">​</a></h2><p>有时候人们会用重复写一些字母来表示额外的感受，比如 <code>&quot;hello&quot; -&gt; &quot;heeellooo&quot;</code>, <code>&quot;hi&quot; -&gt; &quot;hiii&quot;</code>。我们将相邻字母都相同的一串字符定义为相同字母组，例如：&quot;h&quot;, &quot;eee&quot;, &quot;ll&quot;, &quot;ooo&quot;。</p><p>对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 <code>c</code> ），然后往其中添加相同的字母 <code>c</code> 使其长度达到 3 或以上。</p><p>例如，以 &quot;hello&quot; 为例，我们可以对字母组 &quot;o&quot; 扩张得到 &quot;hellooo&quot;，但是无法以同样的方法得到 &quot;helloo&quot; 因为字母组 &quot;oo&quot; 长度小于 3。此外，我们可以进行另一种扩张 &quot;ll&quot; -&gt; &quot;lllll&quot; 以获得 &quot;helllllooo&quot;。如果 <code>s = &quot;helllllooo&quot;</code>，那么查询词 &quot;hello&quot; 是可扩张的，因为可以对它执行这两种扩张操作使得 <code>query = &quot;hello&quot; -&gt; &quot;hellooo&quot; -&gt; &quot;helllllooo&quot; = s</code>。</p><p>输入一组查询单词，输出其中可扩张的单词数量。</p><p><strong>示例：</strong></p><p><strong>输入：</strong>
s = &quot;heeellooo&quot;
words = <!-- -->[<!-- -->&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;<!-- -->]<!-- -->
<strong>输出：</strong>1
<strong>解释</strong>：
我们能通过扩张 &quot;hello&quot; 的 &quot;e&quot; 和 &quot;o&quot; 来得到 &quot;heeellooo&quot;。
我们不能通过扩张 &quot;helo&quot; 来得到 &quot;heeellooo&quot; 因为 &quot;ll&quot; 的长度小于 3 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 100</code></li><li>s 和所有在 <code>words</code> 中的单词都只由小写字母组成。</li></ul><blockquote><p>Problem: <a href="https://leetcode.cn/problems/expressive-words/description/" target="_blank" rel="noopener noreferrer">809. 情感丰富的文字</a></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="2思路">2、思路<a class="hash-link" href="#2思路" title="标题的直接链接">​</a></h2><p>总体思路是：先提取字符串 <code>s</code> 的 <code>pattern</code>，然后遍历 <code>words</code> 中每一项是否与 <code>pattern</code> 相匹配。这里使用正则实现。</p><ul><li>提取字符串 <code>s</code> 的正则<ul><li>将 <code>s</code> 中连续 3 个以上相同的字符 <code>a</code> 替换为 <code>a{1,a.count}</code>，比如 <code>ooooo</code> 替换为 <code>o{1,5}</code></li><li>替换后的字符串添加首尾标志 <code>^</code>、<code>$</code> 并转为正则</li></ul></li><li>遍历 <code>words</code> 并与正则匹配，若匹配则结果累计 1</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="3code">3、Code<a class="hash-link" href="#3code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function expressiveWords(s: string, words: string[]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const r = s.replace(/(\w)\1{2,}/g, (m, a) =&gt; `${a}{1,${m.length}}`);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const reg = new RegExp(`^${r}$`);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return words.reduce((a, c) =&gt; a + +reg.test(c), 0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="4执行结果">4、执行结果<a class="hash-link" href="#4执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1669342722-GiwQOz-image.png" alt="image.png" class="img_jWLO"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_zFUd padding--none margin-left--sm"><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数组/">数组</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/双指针/">双指针</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/字符串/">字符串</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_mBgL" itemprop="headline"><a itemprop="url" href="/algorithm/891.子序列宽度之和/">891.子序列宽度之和</a></h2><div class="container_hz_z margin-vert--md"><time datetime="2022-11-18T00:00:00.000Z" itemprop="datePublished">2022年11月18日</time> · <!-- -->阅读需 3 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_uuk1"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="1题干">1、题干<a class="hash-link" href="#1题干" title="标题的直接链接">​</a></h2><p>一个序列的 <strong>宽度</strong> 定义为该序列中最大元素和最小元素的差值。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 <strong>子序列</strong> 的 <strong>宽度之和</strong> 。由于答案可能非常大，请返回对 <code>10^9 + 7</code> <strong>取余</strong> 后的结果。</p><p><strong>子序列</strong> 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> nums = <!-- -->[<!-- -->2,1,3<!-- -->]<br>
<strong>输出：</strong> 6<br>
<strong>解释：</strong> 子序列为 <!-- -->[<!-- -->1<!-- -->]<!-- -->, <!-- -->[<!-- -->2<!-- -->]<!-- -->, <!-- -->[<!-- -->3<!-- -->]<!-- -->, <!-- -->[<!-- -->2,1<!-- -->]<!-- -->, <!-- -->[<!-- -->2,3<!-- -->]<!-- -->, <!-- -->[<!-- -->1,3<!-- -->]<!-- -->, <!-- -->[<!-- -->2,1,3<!-- -->]<!-- --> 。<br>
相应的宽度是 0, 0, 0, 1, 1, 2, 2 。<br>
宽度之和是 6 。<br></p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> nums = <!-- -->[<!-- -->2<!-- -->]<br>
<strong>输出：</strong> 0<br></p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><blockquote><p>Problem: <a href="https://leetcode.cn/problems/sum-of-subsequence-widths/description/" target="_blank" rel="noopener noreferrer">891. 子序列宽度之和</a></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="2思路">2、思路<a class="hash-link" href="#2思路" title="标题的直接链接">​</a></h2><p>还得是按官解的排序+计算贡献值的思路去做：</p><ul><li>对长度为 <code>n</code> 的整数数组 <code>nums</code> 升序排列</li><li>数组 <code>nums</code> 中第 <code>i</code> 个整数贡献的最小值次数是： $2 ^ {n-i-1} - 1$</li><li>数组 <code>nums</code> 中第 <code>i</code> 个整数贡献的最大值次数是： $2 ^ i - 1$</li><li>累计每个元素的贡献值 $nums<!-- -->[i]<!-- --> <em> (2 ^ i - 1) - nums<!-- -->[i]<!-- --> </em> (2 ^ {n-i-1} - 1)$</li></ul><p>计算贡献次数实际是计算组合数：$C<em>{n}^{1} + C</em>{n}^{2} + ... + C_{n}^{n}$</p><p>由于数据过大需要取余，第一版用快速幂实现，居然只通过了 20+ 个用例，真是裂开了😳；把快速幂改成打表后过了。。。</p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="3code">3、Code<a class="hash-link" href="#3code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function sumSubseqWidths(nums: number[]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const n = nums.length, MOD = 1e9 + 7;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    nums.sort((a, b) =&gt; a - b);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const pow = new Array(n).fill(1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 1; i &lt; n; i++) pow[i] = 2 * pow[i - 1] % MOD;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let res = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; n; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        res = (res + nums[i] * (pow[i] - pow[n - i - 1])) % MOD;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="4复杂度">4、复杂度<a class="hash-link" href="#4复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(n*logn)$</li><li>空间复杂度：$O(n)$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="5执行结果">5、执行结果<a class="hash-link" href="#5执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1668741523-WyQpgw-image.png" alt="image.png" class="img_jWLO"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_zFUd padding--none margin-left--sm"><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数组/">数组</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数学/">数学</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/排序/">排序</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_mBgL" itemprop="headline"><a itemprop="url" href="/algorithm/775.全局倒置与局部倒置/">775.全局倒置与局部倒置</a></h2><div class="container_hz_z margin-vert--md"><time datetime="2022-11-16T00:00:00.000Z" itemprop="datePublished">2022年11月16日</time> · <!-- -->阅读需 4 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_uuk1"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="1题干">1、题干<a class="hash-link" href="#1题干" title="标题的直接链接">​</a></h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，表示由范围 <code>[0, n - 1]</code> 内所有整数组成的一个排列。</p><p><strong>全局倒置</strong> 的数目等于满足下述条件不同下标对 <code>(i, j)</code> 的数目：</p><ul><li><code>0 &lt;= i &lt; j &lt; n</code></li><li><code>nums[i] &gt; nums[j]</code></li></ul><p><strong>局部倒置</strong> 的数目等于满足下述条件的下标 <code>i</code> 的数目：</p><ul><li><code>0 &lt;= i &lt; n - 1</code></li><li><code>nums[i] &gt; nums[i + 1]</code></li></ul><p>当数组 <code>nums</code> 中 <strong>全局倒置</strong> 的数量等于 <strong>局部倒置</strong> 的数量时，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> nums = <!-- -->[<!-- -->1,0,2<!-- -->]<br>
<strong>输出：</strong> true<br>
<strong>解释：</strong> 有 1 个全局倒置，和 1 个局部倒置。<br></p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> nums = <!-- -->[<!-- -->1,2,0<!-- -->]<br>
<strong>输出：</strong> false<br>
<strong>解释：</strong> 有 2 个全局倒置，和 1 个局部倒置。<br></p></blockquote><blockquote><p> <br></p></blockquote><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt; n</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 是范围 <code>[0, n - 1]</code> 内所有数字组成的一个排列</li></ul><blockquote><p>Problem: <a href="https://leetcode.cn/problems/global-and-local-inversions/description/" target="_blank" rel="noopener noreferrer">775. 全局倒置与局部倒置</a></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="2思路1">2、思路1<a class="hash-link" href="#2思路1" title="标题的直接链接">​</a></h2><p>根据题意可知，局部倒置是全局倒置，全局倒置不一定是局部倒置，因此全局倒置的数量必然大于等于局部倒置。</p><p>当数组 <code>nums</code> 升序排列时不存在倒置情况，若将任意整数 <code>k</code> 置换到位置 <code>i</code> 就会出现倒置，二者差值大于 <code>1</code> 时必然会出现全局倒置的数量大于局部倒置。</p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="3code">3、Code<a class="hash-link" href="#3code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function isIdealPermutation(nums: number[]): boolean {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; nums.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (Math.abs(nums[i] - i) &gt; 1) return false;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="4复杂度">4、复杂度<a class="hash-link" href="#4复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="5执行结果">5、执行结果<a class="hash-link" href="#5执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1668591065-MFtYCF-image.png" alt="image.png" class="img_jWLO"></p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="6思路2">6、思路2<a class="hash-link" href="#6思路2" title="标题的直接链接">​</a></h2><p>累计局部倒置数量 <code>pc</code> 和全局倒置数量 <code>ac</code>，当 <code>nums[i] &gt; nums[i + 1]</code> 时 <code>pc</code> 加 <code>1</code>，当 <code>nums[i] &gt; i</code> 时 <code>ac</code> 加 <code>nums[i] - i</code>，最后判断二者是否相等。其中有一种特殊情况：出现3个连续递减的数时全局倒置数量必定大于倒置数量。</p><blockquote><p>这个思路正确性没有验证，完全是运气通过</p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="7code">7、Code<a class="hash-link" href="#7code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function isIdealPermutation(nums: number[]): boolean {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let pc = 0, ac = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; nums.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (nums[i] &gt; nums[i + 1] &amp;&amp; nums[i + 1] &gt; nums[i + 2]) return false;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (nums[i] &gt; nums[i + 1]) pc++;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (nums[i] &gt; i) ac += nums[i] - i;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return pc === ac;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="8复杂度">8、复杂度<a class="hash-link" href="#8复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="9执行结果">9、执行结果<a class="hash-link" href="#9执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1668591118-jmlyLY-image.png" alt="image.png" class="img_jWLO"></p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="10思路3">10、思路3<a class="hash-link" href="#10思路3" title="标题的直接链接">​</a></h2><p>单调栈，耗时很长</p><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="11code">11、Code<a class="hash-link" href="#11code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function isIdealPermutation(nums: number[]): boolean {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let pc = 0, ac = 0, stack = [];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; nums.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (nums[i] &gt; nums[i + 1]) pc++;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (!stack.length || stack.at(-1) &gt; nums[i]) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            ac += stack.length;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            stack.push(nums[i]);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            const j = stack.findIndex(s =&gt; s &lt; nums[i]);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            ac += j;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            stack.splice(j, 0, nums[i]);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return pc === ac;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="12复杂度">12、复杂度<a class="hash-link" href="#12复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n)$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="13执行结果">13、执行结果<a class="hash-link" href="#13执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1668591829-KRaVMg-image.png" alt="image.png" class="img_jWLO"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_zFUd padding--none margin-left--sm"><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数组/">数组</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数学/">数学</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_mBgL" itemprop="headline"><a itemprop="url" href="/algorithm/864.获取所有钥匙的最短路径/">864.获取所有钥匙的最短路径</a></h2><div class="container_hz_z margin-vert--md"><time datetime="2022-11-10T00:00:00.000Z" itemprop="datePublished">2022年11月10日</time> · <!-- -->阅读需 5 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_uuk1"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="1题干">1、题干<a class="hash-link" href="#1题干" title="标题的直接链接">​</a></h2><p>给定一个二维网格 <code>grid</code> ，其中：</p><ul><li>&#x27;.&#x27; 代表一个空房间</li><li>&#x27;#&#x27; 代表一堵墙</li><li>&#x27;@&#x27; 是起点</li><li>小写字母代表钥匙</li><li>大写字母代表锁</li></ul><p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙/锁 的个数，且满足 <code>1 &lt;= k &lt;= 6</code>，字母表中的前 <code>k</code> 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p><img loading="lazy" src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg" class="img_jWLO"><br></p></blockquote><blockquote><p><strong>输入：</strong> grid = <!-- -->[<!-- -->&quot;@.a.#&quot;,&quot;###.#&quot;,&quot;b.A.B&quot;<!-- -->]<br>
<strong>输出：</strong> 8<br>
<strong>解释：</strong> 目标是获得所有钥匙，而不是打开所有锁。<br></p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><img loading="lazy" src="https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg" class="img_jWLO"><br></p></blockquote><blockquote><p><strong>输入：</strong> grid = <!-- -->[<!-- -->&quot;@..aA&quot;,&quot;..B#.&quot;,&quot;....b&quot;<!-- -->]<br>
<strong>输出：</strong> 6<br></p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><img loading="lazy" src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg" class="img_jWLO"><br></p></blockquote><blockquote><p><strong>输入:</strong>  grid = <!-- -->[<!-- -->&quot;@Aa&quot;<!-- -->]<br>
<strong>输出:</strong>  -1<br></p></blockquote><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 30</code></li><li><code>grid[i][j]</code> 只含有 <code>&#x27;.&#x27;</code>, <code>&#x27;#&#x27;</code>, <code>&#x27;@&#x27;</code>, <code>&#x27;a&#x27;-``&#x27;f``&#x27;</code> 以及 <code>&#x27;A&#x27;-&#x27;F&#x27;</code></li><li>钥匙的数目范围是 <code>[1, 6]</code> </li><li>每个钥匙都对应一个 <strong>不同</strong> 的字母</li><li>每个钥匙正好打开一个对应的锁</li></ul><blockquote><p>Problem: <a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/" target="_blank" rel="noopener noreferrer">864. 获取所有钥匙的最短路径</a></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="2思路">2、思路<a class="hash-link" href="#2思路" title="标题的直接链接">​</a></h2><p>写过最长的代码，心态崩了</p><p>思路：</p><ul><li>回溯，对所有钥匙进行排列组合，得到所有路径（不校验路径是否连通）</li><li>遍历所有路径，累计从起点经过所有钥匙需要的步数，结果取最小步数</li><li>广搜计算两把钥匙之间的最短路径（需要校验路径是否连通）</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="3code">3、Code<a class="hash-link" href="#3code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function shortestPathAllKeys(grid: string[]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const m = grid.length, n = grid[0].length;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const M = 10007;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const encode = (i: number, j: number) =&gt; i * M + j;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const decode = (d: number) =&gt; [(d / M) &gt;&gt; 0, d % M];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let start = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const keys: number[] = [];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; m; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (let j = 0; j &lt; n; j++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if (grid[i][j] === &quot;@&quot;) start = encode(i, j);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if (grid[i][j] &gt;= &quot;a&quot; &amp;&amp; grid[i][j] &lt;= &quot;f&quot;) keys.push(encode(i, j));</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // 寻找两把钥匙之间的最短路径</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    function bfs(source: number, target: number, visited: Set&lt;number&gt;, foundKeys: Set&lt;string&gt;): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let queue = [source];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        const [ti, tj] = decode(target);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let step = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        while (queue.length) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            const nextQueue = new Set&lt;number&gt;();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            for (const q of queue) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                if (visited.has(q)) continue;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                visited.add(q);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                const [qi, qj] = decode(q);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                const dirs = [[qi, qj + 1], [qi, qj - 1], [qi + 1, qj], [qi - 1, qj],];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                for (const [i, j] of dirs) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    if (!grid[i] || !grid[i][j] || grid[i][j] === &quot;#&quot;) continue;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    if (grid[i][j] &gt;= &quot;A&quot; &amp;&amp; grid[i][j] &lt;= &quot;F&quot; &amp;&amp; !foundKeys.has(grid[i][j].toLowerCase())) continue;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    if (i === ti &amp;&amp; j === tj) return step;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                    nextQueue.add(encode(i, j));</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            step++;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            queue = [...nextQueue];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // 遍历所有路径，累计从起点经过所有钥匙需要的步数，结果取最小步数</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let res = Infinity;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    function calcSteps(path: Set&lt;number&gt;) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let step = 0, source = start, foundKeys = new Set&lt;string&gt;();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (const p of path) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            const st = bfs(source, p, new Set(), foundKeys);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            step += st;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if (!st || step &gt;= res) return;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            const [pi, pj] = decode(p);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            foundKeys.add(grid[pi][pj]);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            source = p;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (step &lt; res) res = step;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // 对钥匙进行排列组合</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    function dfs(path: Set&lt;number&gt;) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (const k of keys) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if (path.has(k)) continue;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            path.add(k);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            dfs(path);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if (path.size === keys.length) calcSteps(path);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            path.delete(k);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    dfs(new Set());</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return res === Infinity ? -1 : res;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="4复杂度">4、复杂度<a class="hash-link" href="#4复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(k!*mn)$</li><li>空间复杂度：$O(mn)$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="5执行结果">5、执行结果<a class="hash-link" href="#5执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1668078530-biAQkG-image.png" alt="image.png" class="img_jWLO"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_zFUd padding--none margin-left--sm"><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/位运算/">位运算</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/广度优先搜索/">广度优先搜索</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数组/">数组</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/矩阵/">矩阵</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_mBgL" itemprop="headline"><a itemprop="url" href="/algorithm/764.最大加号标志/">764.最大加号标志</a></h2><div class="container_hz_z margin-vert--md"><time datetime="2022-11-09T00:00:00.000Z" itemprop="datePublished">2022年11月9日</time> · <!-- -->阅读需 3 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_uuk1"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="1题干">1、题干<a class="hash-link" href="#1题干" title="标题的直接链接">​</a></h2><p>在一个 <code>n x n</code> 的矩阵 <code>grid</code> 中，除了在数组 <code>mines</code> 中给出的元素为 <code>0</code>，其他每个元素都为 <code>1</code>。<code>mines[i] = [xi, yi]</code>表示 <code>grid[xi][yi] == 0</code></p><p>返回  <code>grid</code> <em>中包含 <code>1</code> 的最大的 <strong>轴对齐</strong> 加号标志的阶数</em> 。如果未找到加号标志，则返回 <code>0</code> 。</p><p>一个 <code>k</code> 阶由 <em><code>1</code></em> 组成的 <strong>“轴对称”加号标志</strong> 具有中心网格 <code>grid[r][c] == 1</code> ，以及4个从中心向上、向下、向左、向右延伸，长度为 <code>k-1</code>，由 <code>1</code> 组成的臂。注意，只有加号标志的所有网格要求为 <code>1</code> ，别的网格可能为 <code>0</code> 也可能为 <code>1</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p><img loading="lazy" src="https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg" class="img_jWLO"><br></p></blockquote><blockquote><p><strong>输入:</strong>  n = 5, mines = <!-- -->[<!-- -->[<!-- -->4, 2<!-- -->]<!-- -->]<br>
<strong>输出:</strong>  2<br>
<strong>解释:</strong>  在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。<br></p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><img loading="lazy" src="https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg" class="img_jWLO"><br></p></blockquote><blockquote><p><strong>输入:</strong>  n = 1, mines = <!-- -->[<!-- -->[<!-- -->0, 0<!-- -->]<!-- -->]<br>
<strong>输出:</strong>  0<br>
<strong>解释:</strong>  没有加号标志，返回 0 。<br></p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 500</code></li><li><code>1 &lt;= mines.length &lt;= 5000</code></li><li><code>0 &lt;= xi, yi &lt; n</code></li><li>每一对 <code>(xi, yi)</code> 都 <strong>不重复</strong>​​​​​​​</li></ul><blockquote><p>Problem: <a href="https://leetcode.cn/problems/largest-plus-sign/description/" target="_blank" rel="noopener noreferrer">764. 最大加号标志</a></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="2思路">2、思路<a class="hash-link" href="#2思路" title="标题的直接链接">​</a></h2><ul><li>暴力：遍历矩阵 <code>grid</code>，把每个网格当成中心，计算加号标志的最大阶数 <code>k</code> </li><li>哈希：把 <code>0</code> 网格的坐标转换成哈希表降低查找时间复杂度</li><li>剪枝：遍历过程中，通过当前求得的最大阶数 <code>k</code> 进一步缩小遍历范围</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="3code">3、Code<a class="hash-link" href="#3code" title="标题的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function orderOfLargestPlusSign(n: number, mines: number[][]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const M = 10007, hash = (x: number, y: number) =&gt; x * M + y;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const set = new Set(mines.map(([x, y]) =&gt; hash(x, y)));</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let k = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; n - k; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (let j = k; i &gt;= k &amp;&amp; j &lt; n - k; j++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            for (let l = 0; l &lt; n / 2; l++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                if (i &lt; l || j &lt; l || i + l &gt;= n || j + l &gt;= n) break;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                if (set.has(hash(i, j + l)) || set.has(hash(i, j - l)) || set.has(hash(i + l, j)) || set.has(hash(i - l, j))) break;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                k = Math.max(k, l + 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return k;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="4复杂度">4、复杂度<a class="hash-link" href="#4复杂度" title="标题的直接链接">​</a></h2><ul><li>时间复杂度：$O(n^3)$</li><li>空间复杂度：$O(m)$，$m=mines.length$</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="5执行结果">5、执行结果<a class="hash-link" href="#5执行结果" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://pic.leetcode.cn/1667966262-FHmFxq-image.png" alt="image.png" class="img_jWLO"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_zFUd padding--none margin-left--sm"><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数组/">数组</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/动态规划/">动态规划</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_mBgL" itemprop="headline"><a itemprop="url" href="/algorithm/1684.统计一致字符串的数目/">1684.统计一致字符串的数目</a></h2><div class="container_hz_z margin-vert--md"><time datetime="2022-11-08T00:00:00.000Z" itemprop="datePublished">2022年11月8日</time> · <!-- -->阅读需 2 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_uuk1"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_KW95" id="1题干">1、题干<a class="hash-link" href="#1题干" title="标题的直接链接">​</a></h2><p>给你一个由不同字符组成的字符串 <code>allowed</code> 和一个字符串数组 <code>words</code> 。如果一个字符串的每一个字符都在 <code>allowed</code> 中，就称这个字符串是 <strong>一致字符串</strong> 。</p><p>请你返回 <code>words</code> 数组中 <strong>一致字符串</strong> 的数目。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> allowed = &quot;ab&quot;, words = <!-- -->[<!-- -->&quot;ad&quot;,&quot;bd&quot;,&quot;aaab&quot;,&quot;baa&quot;,&quot;badab&quot;<!-- -->]<br>
<strong>输出：</strong> 2<br>
<strong>解释：</strong> 字符串 &quot;aaab&quot; 和 &quot;baa&quot; 都是一致字符串，因为它们只包含字符 &#x27;a&#x27; 和 &#x27;b&#x27; 。<br></p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> allowed = &quot;abc&quot;, words = <!-- -->[<!-- -->&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;abc&quot;<!-- -->]<br>
<strong>输出：</strong> 7<br>
<strong>解释：</strong> 所有字符串都是一致的。<br></p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> allowed = &quot;cad&quot;, words = <!-- -->[<!-- -->&quot;cc&quot;,&quot;acd&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bac&quot;,&quot;bad&quot;,&quot;ac&quot;,&quot;d&quot;<!-- -->]<br>
<strong>输出：</strong> 4<br>
<strong>解释：</strong> 字符串 &quot;cc&quot;，&quot;acd&quot;，&quot;ac&quot; 和 &quot;d&quot; 是一致字符串。<br></p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 10^4</code></li><li><code>1 &lt;= allowed.length &lt;= 26</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>allowed</code> 中的字符 <strong>互不相同</strong> 。</li><li><code>words[i]</code> 和 <code>allowed</code> 只包含小写英文字母。</li></ul><blockquote><p>Problem: <a href="https://leetcode.cn/problems/count-the-number-of-consistent-strings/description/" target="_blank" rel="noopener noreferrer">1684. 统计一致字符串的数目</a></p></blockquote><p>[TOC]</p><h1>思路</h1><p>reduce 跟 for of 耗费的时间空间差距还挺大</p><h1>Code - for of</h1><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function countConsistentStrings(allowed: string, words: string[]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const dict = new Set(allowed);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let res = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    loop: for (const s of words) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (const c of s) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if (!dict.has(c)) continue loop;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        res++;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" src="https://pic.leetcode.cn/1667872347-pBpBlZ-image.png" alt="image.png" class="img_jWLO"></p><h1>Code - reduce</h1><div class="language-TypeScript codeBlockContainer_u9qM theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_jm0m"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_Tj6U thin-scrollbar"><code class="codeBlockLines_k4aa"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function countConsistentStrings(allowed: string, words: string[]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const dict = new Set(allowed);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return words.reduce((a, s) =&gt; a + +([].every.call(s, (c) =&gt; dict.has(c))), 0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup_oe9o"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_cRWi" aria-hidden="true"><svg class="copyButtonIcon_u5rO" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_rKVj" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" src="https://pic.leetcode.cn/1667872378-HSPaHP-image.png" alt="image.png" class="img_jWLO"></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_zFUd padding--none margin-left--sm"><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/位运算/">位运算</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/数组/">数组</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/哈希表/">哈希表</a></li><li class="tag_G89Y"><a class="tag_uJPw tagRegular_Wsjd" href="/algorithm/tags/字符串/">字符串</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/algorithm/tags/数组/"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/algorithm/tags/数组/page/3/"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Whilconn. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.b2c3c553.js"></script>
<script src="/assets/js/main.8c1187cf.js"></script>
</body>
</html>