<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-algorithm">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">Blog | D9笔记</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://whilconn.github.io/algorithm/"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="Blog | D9笔记"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/img/avatar.png"><link data-rh="true" rel="canonical" href="https://whilconn.github.io/algorithm/"><link data-rh="true" rel="alternate" href="https://whilconn.github.io/algorithm/" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://whilconn.github.io/algorithm/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="D9笔记 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="D9笔记 Atom Feed">



<link rel="alternate" type="application/rss+xml" href="/algorithm/rss.xml" title="D9笔记 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/algorithm/atom.xml" title="D9笔记 Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.f62d8806.css">
<link rel="preload" href="/assets/js/runtime~main.a1c0d390.js" as="script">
<link rel="preload" href="/assets/js/main.a5467f83.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/avatar.png" alt="D9笔记" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/avatar.png" alt="D9笔记" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">D9笔记</b></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">首页</a><a class="navbar__item navbar__link" href="/portals/">导航</a><a class="navbar__item navbar__link" href="/blog/">博客</a><a class="navbar__item navbar__link" href="/algorithm/archive/">算法题解</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为暗黑模式）" aria-label="切换浅色/暗黑模式（当前为暗黑模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">最新文章</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/algorithm/2023/12/04/1038.从二叉搜索树到更大和树/">1038.从二叉搜索树到更大和树</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/algorithm/2023/12/01/2661.找出叠涂元素/">2661.找出叠涂元素</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/algorithm/2023/11/30/1657.确定两个字符串是否接近/">1657.确定两个字符串是否接近</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/algorithm/2023/11/29/2336.无限集中的最小数字/">2336.无限集中的最小数字</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/algorithm/2023/11/28/106.从中序与后序遍历序列构造二叉树/">106.从中序与后序遍历序列构造二叉树</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/algorithm/2023/11/21/2216.美化数组的最少删除数/">2216.美化数组的最少删除数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/algorithm/2023/11/17/88.合并两个有序数组/">88.合并两个有序数组</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/algorithm/2023/11/16/2760.最长奇偶子数组/">2760.最长奇偶子数组</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/algorithm/2023/11/15/2656.K 个元素的最大和/">2656.K 个元素的最大和</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/algorithm/2023/11/15/58.最后一个单词的长度/">58.最后一个单词的长度</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/algorithm/2023/12/04/1038.从二叉搜索树到更大和树/">1038.从二叉搜索树到更大和树</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-12-04T00:00:00.000Z" itemprop="datePublished">2023年12月4日</time> · <!-- -->阅读需 2 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1题干">1、题干<a href="#1题干" class="hash-link" aria-label="1、题干的直接链接" title="1、题干的直接链接">​</a></h2><p><span><span><span><span><font face="宋体">给定一个二叉搜索树</font></span></span></span></span> <code>root</code> (BST)<span><span><span><span><font face="宋体">，请将它的每个</font></span></span></span></span>节点<span><span><span><span><font face="宋体">的值替换成树中大于或者等于该</font></span></span></span></span>节点<span><span><span><span><font face="宋体">值的所有</font></span></span></span></span>节点<span><span><span><span><font face="宋体">值之和。</font></span></span></span></span></p><p>提醒一下， <em>二叉搜索树</em> 满足下列约束条件：</p><ul><li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li><li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p> </p><p><strong>示例 1：</strong></p><p><strong><img loading="lazy" alt="" src="/assets/images/d5bc62df2367d7950927b68dc248a147-164945e9e6de6747b46dc822d9a76517.png" class="img_ev3q"></strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br><strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]<br></code></pre><p><strong>示例 2：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>root = [0,null,1]<br><strong>输出：</strong>[1,null,1]<br></code></pre><p> </p><p><strong>提示：</strong></p><ul><li>树中的节点数在 <code>[1, 100]</code> 范围内。</li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li>树中的所有值均 <strong>不重复</strong> 。</li></ul><p> </p><p><strong>注意：</strong>该题目与 538: <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener noreferrer">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/  </a>相同</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2思路">2、思路<a href="#2思路" class="hash-link" aria-label="2、思路的直接链接" title="2、思路的直接链接">​</a></h2><p>根据题意使用DFS模拟，需要注意：</p><ul><li>对左子节点求和，需要将父节点求和结果、右子树节点之和、自身数值3者累加</li><li>对右子节点求和，需要将右边祖先节点求和结果、右子树节点之和、自身数值3者累加</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3代码">3、代码<a href="#3代码" class="hash-link" aria-label="3、代码的直接链接" title="3、代码的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function bstToGst(root: TreeNode | null): TreeNode | null {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return dfs(root), root;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">function dfs(root?: TreeNode, pSum = 0): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if (!root) return 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const val = root.val;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const rSum = dfs(root.right, pSum);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    root.val = val + pSum + rSum;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const lSum = dfs(root.left, root.val);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return val + rSum + lSum;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/树/">树</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/深度优先搜索/">深度优先搜索</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/二叉搜索树/">二叉搜索树</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/二叉树/">二叉树</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/algorithm/2023/12/01/2661.找出叠涂元素/">2661.找出叠涂元素</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-12-01T00:00:00.000Z" itemprop="datePublished">2023年12月1日</time> · <!-- -->阅读需 2 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1题干">1、题干<a href="#1题干" class="hash-link" aria-label="1、题干的直接链接" title="1、题干的直接链接">​</a></h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 和一个 <code>m x n</code> 的整数 <strong>矩阵</strong> <code>mat</code> 。<code>arr</code> 和 <code>mat</code> 都包含范围 <code>[1，m * n]</code> 内的 <strong>所有</strong> 整数。</p><p>从下标 <code>0</code> 开始遍历 <code>arr</code> 中的每个下标 <code>i</code> ，并将包含整数 <code>arr[i]</code> 的 <code>mat</code> 单元格涂色。</p><p>请你找出 <code>arr</code> 中第一个使得 <code>mat</code> 的某一行或某一列都被涂色的元素，并返回其下标 <code>i</code> 。</p><p> </p><p><strong>示例 1：</strong></p><img loading="lazy" alt="image explanation for example 1" src="data:image/jpeg;base64,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" class="img_ev3q"><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>arr = [1,3,4,2], mat = [[1,4],[2,3]]<br><strong>输出：</strong>2<br><strong>解释：</strong>遍历如上图所示，arr[2] 在矩阵中的第一行或第二列上都被涂色。<br></code></pre><p><strong>示例 2：</strong></p><img loading="lazy" alt="image explanation for example 2" src="https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg" class="img_ev3q"><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]<br><strong>输出：</strong>3<br><strong>解释：</strong>遍历如上图所示，arr[3] 在矩阵中的第二列上都被涂色。<br></code></pre><p> </p><p><strong>提示：</strong></p><ul><li><code>m == mat.length</code></li><li><code>n = mat[i].length</code></li><li><code>arr.length == m * n</code></li><li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li><li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li><li><code>1 &lt;= arr[i], mat[r][c] &lt;= m * n</code></li><li><code>arr</code> 中的所有整数 <strong>互不相同</strong></li><li><code>mat</code> 中的所有整数 <strong>互不相同</strong></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2思路">2、思路<a href="#2思路" class="hash-link" aria-label="2、思路的直接链接" title="2、思路的直接链接">​</a></h2><p>模拟题，对行列涂色计数即可</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3代码">3、代码<a href="#3代码" class="hash-link" aria-label="3、代码的直接链接" title="3、代码的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function firstCompleteIndex(arr: number[], mat: number[][]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const map = new Array(arr.length + 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; mat.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (let j = 0; j &lt; mat[i].length; j++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            map[mat[i][j]] = [i, j];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const rows = new Array(mat.length).fill(0), cols = new Array(mat[0].length).fill(0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        const [r, c] = map[arr[i]];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        rows[r]++, cols[c]++;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (rows[r] === mat[0].length || cols[c] === mat.length) return i;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return -1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/数组/">数组</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/哈希表/">哈希表</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/矩阵/">矩阵</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/algorithm/2023/11/30/1657.确定两个字符串是否接近/">1657.确定两个字符串是否接近</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-11-30T00:00:00.000Z" itemprop="datePublished">2023年11月30日</time> · <!-- -->阅读需 3 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1题干">1、题干<a href="#1题干" class="hash-link" aria-label="1、题干的直接链接" title="1、题干的直接链接">​</a></h2><p>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 <strong>接近</strong> ：</p><ul><li>操作 1：交换任意两个 <strong>现有</strong> 字符。<ul><li>例如，<code>a<strong>b</strong>cd<strong>e</strong> -&gt; a<strong>e</strong>cd<strong>b</strong></code></li></ul></li><li>操作 2：将一个 <strong>现有</strong> 字符的每次出现转换为另一个 <strong>现有</strong> 字符，并对另一个字符执行相同的操作。<ul><li>例如，<code><strong>aa</strong>c<strong>abb</strong> -&gt; <strong>bb</strong>c<strong>baa</strong></code>（所有 <code>a</code> 转化为 <code>b</code> ，而所有的 <code>b</code> 转换为 <code>a</code> ）</li></ul></li></ul><p>你可以根据需要对任意一个字符串多次使用这两种操作。</p><p>给你两个字符串，<code>word1</code> 和 <code>word2</code> 。如果<em> </em><code>word1</code><em> </em>和<em> </em><code>word2</code><em> </em><strong>接近 </strong>，就返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p><p> </p><p><strong>示例 1：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>word1 = &quot;abc&quot;, word2 = &quot;bca&quot;<br><strong>输出：</strong>true<br><strong>解释：</strong>2 次操作从 word1 获得 word2 。<br>执行操作 1：&quot;a<strong>bc</strong>&quot; -&gt; &quot;a<strong>cb</strong>&quot;<br>执行操作 1：&quot;<strong>a</strong>c<strong>b</strong>&quot; -&gt; &quot;<strong>b</strong>c<strong>a</strong>&quot;<br></code></pre><p><strong>示例 2：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>word1 = &quot;a&quot;, word2 = &quot;aa&quot;<br><strong>输出：</strong>false<br><strong>解释：</strong>不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。</code></pre><p><strong>示例 3：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>word1 = &quot;cabbba&quot;, word2 = &quot;abbccc&quot;<br><strong>输出：</strong>true<br><strong>解释：</strong>3 次操作从 word1 获得 word2 。<br>执行操作 1：&quot;ca<strong>b</strong>bb<strong>a</strong>&quot; -&gt; &quot;ca<strong>a</strong>bb<strong>b</strong>&quot;<br>执行操作 2：<code>&quot;</code><strong>c</strong>aa<strong>bbb</strong>&quot; -&gt; &quot;<strong>b</strong>aa<strong>ccc</strong>&quot;<br>执行操作 2：&quot;<strong>baa</strong>ccc&quot; -&gt; &quot;<strong>abb</strong>ccc&quot;<br></code></pre><p><strong>示例 4：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>word1 = &quot;cabbba&quot;, word2 = &quot;aabbss&quot;<br><strong>输出：</strong>false<br><strong>解释：</strong>不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。</code></pre><p> </p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 10<sup>5</sup></code></li><li><code>word1</code> 和 <code>word2</code> 仅包含小写英文字母</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2思路">2、思路<a href="#2思路" class="hash-link" aria-label="2、思路的直接链接" title="2、思路的直接链接">​</a></h2><p>需要校验两个关键点：</p><ul><li>两个字符串包含的字母相同</li><li>两个字符串分别按字母计数，计数结果排序后相同</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3代码">3、代码<a href="#3代码" class="hash-link" aria-label="3、代码的直接链接" title="3、代码的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function closeStrings(word1: string, word2: string): boolean {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if (word1.length !== word2.length) return false;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const K = 26, AC = &#x27;a&#x27;.charCodeAt(0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const c1 = new Array(K).fill(0), c2 = new Array(K).fill(0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; word1.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        c1[word1.charCodeAt(i) - AC] += 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        c2[word2.charCodeAt(i) - AC] += 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return c1.every((c, i) =&gt; +!c === +!c2[i]) &amp;&amp; c1.sort().toString() === c2.sort().toString();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/哈希表/">哈希表</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/字符串/">字符串</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/排序/">排序</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/algorithm/2023/11/29/2336.无限集中的最小数字/">2336.无限集中的最小数字</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-11-29T00:00:00.000Z" itemprop="datePublished">2023年11月29日</time> · <!-- -->阅读需 3 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1题干">1、题干<a href="#1题干" class="hash-link" aria-label="1、题干的直接链接" title="1、题干的直接链接">​</a></h2><p>现有一个包含所有正整数的集合 <code>[1, 2, 3, 4, 5, ...]</code> 。</p><p>实现 <code>SmallestInfiniteSet</code> 类：</p><ul><li><code>SmallestInfiniteSet()</code> 初始化 <strong>SmallestInfiniteSet</strong> 对象以包含 <strong>所有</strong> 正整数。</li><li><code>int popSmallest()</code> <strong>移除</strong> 并返回该无限集中的最小整数。</li><li><code>void addBack(int num)</code> 如果正整数 <code>num</code> <strong>不</strong> 存在于无限集中，则将一个 <code>num</code> <strong>添加</strong> 到该无限集最后。</li></ul><p> </p><p><strong>示例：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入</strong><br>[&quot;SmallestInfiniteSet&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;]<br>[[], [2], [], [], [], [1], [], [], []]<br><strong>输出</strong><br>[null, null, 1, 2, 3, null, 1, 4, 5]<br><br><strong>解释</strong><br>SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();<br>smallestInfiniteSet.addBack(2);    // 2 已经在集合中，所以不做任何变更。<br>smallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 是最小的整数，并将其从集合中移除。<br>smallestInfiniteSet.popSmallest(); // 返回 2 ，并将其从集合中移除。<br>smallestInfiniteSet.popSmallest(); // 返回 3 ，并将其从集合中移除。<br>smallestInfiniteSet.addBack(1);    // 将 1 添加到该集合中。<br>smallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 在上一步中被添加到集合中，<br>                                   // 且 1 是最小的整数，并将其从集合中移除。<br>smallestInfiniteSet.popSmallest(); // 返回 4 ，并将其从集合中移除。<br>smallestInfiniteSet.popSmallest(); // 返回 5 ，并将其从集合中移除。</code></pre><p> </p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 1000</code></li><li>最多调用 <code>popSmallest</code> 和 <code>addBack</code> 方法 <strong>共计</strong> <code>1000</code> 次</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2思路">2、思路<a href="#2思路" class="hash-link" aria-label="2、思路的直接链接" title="2、思路的直接链接">​</a></h2><p>两个思路：</p><ul><li>优先队列：直接用优先队列存取数据即可，但要注意数字不能重复，总体最差时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop">lo<span style="margin-right:0.01389em">g</span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></span></li><li>暴力：由于数据范围比较小，可以使用计数排序的思路存取数据进行暴力求解，总体最差时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3代码">3、代码<a href="#3代码" class="hash-link" aria-label="3、代码的直接链接" title="3、代码的直接链接">​</a></h2><p><strong>优先队列</strong></p><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">const N = 1001;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class SmallestInfiniteSet {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    nums = new Array(N).fill(1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    minQueue = new MinPriorityQueue();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    constructor() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (let i = 1; i &lt; N; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            this.minQueue.enqueue(i);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    popSmallest(): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        const n = this.minQueue.dequeue().element;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        this.nums[n] = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return n;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    addBack(num: number): void {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (this.nums[num]) return;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        this.nums[num] = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        this.minQueue.enqueue(num);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>暴力</strong></p><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class SmallestInfiniteSet {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    nums: number[] = [];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    constructor() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        this.nums = new Array(1001).fill(1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    popSmallest(): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        const k = this.nums.findIndex((n, i) =&gt; i &gt; 0 &amp;&amp; n &gt; 0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        this.nums[k] = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return k;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    addBack(num: number): void {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        this.nums[num] = 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/设计/">设计</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/哈希表/">哈希表</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/堆（优先队列）/">堆（优先队列）</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/algorithm/2023/11/28/106.从中序与后序遍历序列构造二叉树/">106.从中序与后序遍历序列构造二叉树</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-11-28T00:00:00.000Z" itemprop="datePublished">2023年11月28日</time> · <!-- -->阅读需 2 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1题干">1、题干<a href="#1题干" class="hash-link" aria-label="1、题干的直接链接" title="1、题干的直接链接">​</a></h2><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p> </p><p><strong>示例 1:</strong></p><img loading="lazy" alt="" src="/assets/images/3191074cd189469c9d9199a126b6d035-69c21fd4b33762fb1eec250ac5d95cd3.jpg" class="img_ev3q"><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><b>输入：</b>inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]<br><b>输出：</b>[3,9,20,null,null,15,7]<br></code></pre><p><strong>示例 2:</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><b>输入：</b>inorder = [-1], postorder = [-1]<br><b>输出：</b>[-1]<br></code></pre><p> </p><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2思路">2、思路<a href="#2思路" class="hash-link" aria-label="2、思路的直接链接" title="2、思路的直接链接">​</a></h2><p>后序遍历数组最后一个元素是根节点，中序遍历数组中根节点前、后两边分别是左子树与右子树，根据这两个性质递归即可，时间复杂度最优 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop">lo<span style="margin-right:0.01389em">g</span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></span>，最差 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3代码">3、代码<a href="#3代码" class="hash-link" aria-label="3、代码的直接链接" title="3、代码的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function buildTree(inorder: number[], postorder: number[]): TreeNode | null {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if (!inorder.length) return null;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const rv = postorder.at(-1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const root = new TreeNode(rv);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const c = inorder.indexOf(rv);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const inLeft = inorder.slice(0, c);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const inRight = inorder.slice(c + 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const postLeft = postorder.slice(0, c);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const postRight = postorder.slice(c, postorder.length - 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    root.left = buildTree(inLeft, postLeft);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    root.right = buildTree(inRight, postRight);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return root;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/树/">树</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/数组/">数组</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/哈希表/">哈希表</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/分治/">分治</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/二叉树/">二叉树</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/algorithm/2023/11/21/2216.美化数组的最少删除数/">2216.美化数组的最少删除数</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-11-21T00:00:00.000Z" itemprop="datePublished">2023年11月21日</time> · <!-- -->阅读需 3 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1题干">1、题干<a href="#1题干" class="hash-link" aria-label="1、题干的直接链接" title="1、题干的直接链接">​</a></h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果满足下述条件，则认为数组 <code>nums</code> 是一个 <strong>美丽数组</strong> ：</p><ul><li><code>nums.length</code> 为偶数</li><li>对所有满足 <code>i % 2 == 0</code> 的下标 <code>i</code> ，<code>nums[i] != nums[i + 1]</code> 均成立</li></ul><p>注意，空数组同样认为是美丽数组。</p><p>你可以从 <code>nums</code> 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 <strong>不变</strong> 。</p><p>返回使 <code>nums</code> 变为美丽数组所需删除的 <strong>最少</strong> 元素数目<em>。</em></p><p> </p><p><strong>示例 1：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>nums = [1,1,2,3,5]<br><strong>输出：</strong>1<br><strong>解释：</strong>可以删除 <code>nums[0]</code> 或 <code>nums[1]</code> ，这样得到的 <code>nums</code> = [1,2,3,5] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。</code></pre><p><strong>示例 2：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>nums = [1,1,2,2,3,3]<br><strong>输出：</strong>2<br><strong>解释：</strong>可以删除 <code>nums[0]</code> 和 <code>nums[5]</code> ，这样得到的 nums = [1,2,2,3] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。<br></code></pre><p> </p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li><li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2思路">2、思路<a href="#2思路" class="hash-link" aria-label="2、思路的直接链接" title="2、思路的直接链接">​</a></h2><p>模拟一遍删除过程就能过。其他题解说是贪心，也有证明过程，看完还是不懂不理解。这题证明比AC难得多。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3代码">3、代码<a href="#3代码" class="hash-link" aria-label="3、代码的直接链接" title="3、代码的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function minDeletion(nums: number[]): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let cur = -Infinity, size = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (const k of nums) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (size % 2 === 0 || k !== cur) cur = k, size++;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return nums.length - size + (size % 2);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/栈/">栈</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/贪心/">贪心</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/数组/">数组</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/algorithm/2023/11/17/88.合并两个有序数组/">88.合并两个有序数组</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-11-17T00:00:00.000Z" itemprop="datePublished">2023年11月17日</time> · <!-- -->阅读需 3 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1题干">1、题干<a href="#1题干" class="hash-link" aria-label="1、题干的直接链接" title="1、题干的直接链接">​</a></h2><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code><em> </em>和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code><em> </em>到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p> </p><p><strong>示例 1：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br><strong>输出：</strong>[1,2,2,3,5,6]<br><strong>解释：</strong>需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [<em><strong>1</strong></em>,<em><strong>2</strong></em>,2,<em><strong>3</strong></em>,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br></code></pre><p><strong>示例 2：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>nums1 = [1], m = 1, nums2 = [], n = 0<br><strong>输出：</strong>[1]<br><strong>解释：</strong>需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br></code></pre><p><strong>示例 3：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>nums1 = [0], m = 0, nums2 = [1], n = 1<br><strong>输出：</strong>[1]<br><strong>解释：</strong>需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。<br></code></pre><p> </p><p><strong>提示：</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li></ul><p> </p><p><strong>进阶：</strong>你可以设计实现一个时间复杂度为 <code>O(m + n)</code> 的算法解决此问题吗？</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2思路">2、思路<a href="#2思路" class="hash-link" aria-label="2、思路的直接链接" title="2、思路的直接链接">​</a></h2><p>两种思路：双指针，合并后排序（无脑暴力）</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3代码">3、代码<a href="#3代码" class="hash-link" aria-label="3、代码的直接链接" title="3、代码的直接链接">​</a></h2><ul><li>双指针</li></ul><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function merge(nums1: number[], m: number, nums2: number[], n: number): void {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const arr1 = nums1.slice(0, m), arr2 = nums2;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let k = 0, i = 0, j = 0; k &lt; m + n; k++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        nums1[k] = j &gt;= n || arr1[i] &lt;= arr2[j] ? arr1[i++] : arr2[j++];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>官解的逆向双指针更优秀，空间复杂度为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，即不需要另外开辟数组辅助，而是优先将结果填充到 <code>nums1</code> 尾部区域</p></blockquote><ul><li>合并排序</li></ul><div class="language-JavaScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-JavaScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">var merge = function (nums1, m, nums2, n) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    nums1.splice(m, n, ...nums2);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return nums1.sort((a, b) =&gt; a - b);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/数组/">数组</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/双指针/">双指针</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/排序/">排序</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/algorithm/2023/11/16/2760.最长奇偶子数组/">2760.最长奇偶子数组</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-11-16T00:00:00.000Z" itemprop="datePublished">2023年11月16日</time> · <!-- -->阅读需 4 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1题干">1、题干<a href="#1题干" class="hash-link" aria-label="1、题干的直接链接" title="1、题干的直接链接">​</a></h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>threshold</code> 。</p><p>请你从 <code>nums</code> 的子数组中找出以下标 <code>l</code> 开头、下标 <code>r</code> 结尾 <code>(0 &lt;= l &lt;= r &lt; nums.length)</code> 且满足以下条件的 <strong>最长子数组</strong> ：</p><ul><li><code>nums[l] % 2 == 0</code></li><li>对于范围 <code>[l, r - 1]</code> 内的所有下标 <code>i</code> ，<code>nums[i] % 2 != nums[i + 1] % 2</code></li><li>对于范围 <code>[l, r]</code> 内的所有下标 <code>i</code> ，<code>nums[i] &lt;= threshold</code></li></ul><p>以整数形式返回满足题目要求的最长子数组的长度。</p><p><strong>注意：子数组</strong> 是数组中的一个连续非空元素序列。</p><p> </p><p><strong>示例 1：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>nums = [3,2,5,4], threshold = 5<br><strong>输出：</strong>3<br><strong>解释：</strong>在这个示例中，我们选择从 l = 1 开始、到 r = 3 结束的子数组 =&gt; [2,5,4] ，满足上述条件。<br>因此，答案就是这个子数组的长度 3 。可以证明 3 是满足题目要求的最大长度。</code></pre><p><strong>示例 2：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>nums = [1,2], threshold = 2<br><strong>输出：</strong>1<br><strong>解释：</strong><br>在这个示例中，我们选择从 l = 1 开始、到 r = 1 结束的子数组 =&gt; [2] 。<br>该子数组满足上述全部条件。可以证明 1 是满足题目要求的最大长度。<br></code></pre><p><strong>示例 3：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>nums = [2,3,4,5], threshold = 4<br><strong>输出：</strong>3<br><strong>解释：</strong><br>在这个示例中，我们选择从 l = 0 开始、到 r = 2 结束的子数组 =&gt; [2,3,4] 。 <br>该子数组满足上述全部条件。<br>因此，答案就是这个子数组的长度 3 。可以证明 3 是满足题目要求的最大长度。</code></pre><p> </p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= threshold &lt;= 100</code></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2思路">2、思路<a href="#2思路" class="hash-link" aria-label="2、思路的直接链接" title="2、思路的直接链接">​</a></h2><p>双指针，暴力枚举</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3代码">3、代码<a href="#3代码" class="hash-link" aria-label="3、代码的直接链接" title="3、代码的直接链接">​</a></h2><ul><li>双指针，时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></li></ul><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function longestAlternatingSubarray(nums: number[], threshold: number): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let ans = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; nums.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (nums[i] % 2 !== 0 || nums[i] &gt; threshold) continue;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let j = i + 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        while (j &lt; nums.length &amp;&amp; nums[j] &lt;= threshold &amp;&amp; nums[j] % 2 !== nums[j - 1] % 2) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            j++;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        ans = Math.max(ans, j - i);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        i = j - 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return ans;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>暴力枚举，时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></li></ul><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function longestAlternatingSubarray(nums: number[], threshold: number): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let ans = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (let i = 0; i &lt; nums.length; i++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if (nums[i] % 2 !== 0) continue;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        for (let j = i; j &lt; nums.length &amp;&amp; nums[j] &lt;= threshold; j++) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            ans = Math.max(ans, j - i + 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if (nums[j] % 2 === nums[j + 1] % 2) break;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return ans;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/数组/">数组</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/滑动窗口/">滑动窗口</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/algorithm/2023/11/15/2656.K 个元素的最大和/">2656.K 个元素的最大和</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-11-15T00:00:00.000Z" itemprop="datePublished">2023年11月15日</time> · <!-- -->阅读需 3 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1题干">1、题干<a href="#1题干" class="hash-link" aria-label="1、题干的直接链接" title="1、题干的直接链接">​</a></h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你需要执行以下操作<strong> 恰好</strong> <code>k</code> 次，最大化你的得分：</p><ol><li>从 <code>nums</code> 中选择一个元素 <code>m</code> 。</li><li>将选中的元素 <code>m</code> 从数组中删除。</li><li>将新元素 <code>m + 1</code> 添加到数组中。</li><li>你的得分增加 <code>m</code> 。</li></ol><p>请你返回执行以上操作恰好 <code>k</code> 次后的最大得分。</p><p> </p><p><strong>示例 1：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><b>输入：</b>nums = [1,2,3,4,5], k = 3<br><b>输出：</b>18<br><b>解释：</b>我们需要从 nums 中恰好选择 3 个元素并最大化得分。<br>第一次选择 5 。和为 5 ，nums = [1,2,3,4,6] 。<br>第二次选择 6 。和为 6 ，nums = [1,2,3,4,7] 。<br>第三次选择 7 。和为 5 + 6 + 7 = 18 ，nums = [1,2,3,4,8] 。<br>所以我们返回 18 。<br>18 是可以得到的最大答案。<br></code></pre><p><strong>示例 2：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><b>输入：</b>nums = [5,5,5], k = 2<br><b>输出：</b>11<br><b>解释：</b>我们需要从 nums 中恰好选择 2 个元素并最大化得分。<br>第一次选择 5 。和为 5 ，nums = [5,5,6] 。<br>第二次选择 6 。和为 6 ，nums = [5,5,7] 。<br>所以我们返回 11 。<br>11 是可以得到的最大答案。<br></code></pre><p> </p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= k &lt;= 100</code></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2思路">2、思路<a href="#2思路" class="hash-link" aria-label="2、思路的直接链接" title="2、思路的直接链接">​</a></h2><p>根据题意可知 <code>k</code> 次得分是首项为 <code>Math.max(...nums)</code> 公差为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span></span> 的等差数列，套用等差数列求和公式即可</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3代码">3、代码<a href="#3代码" class="hash-link" aria-label="3、代码的直接链接" title="3、代码的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function maximizeSum(nums: number[], k: number): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return k * (2 * Math.max(...nums) + k - 1) / 2;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/贪心/">贪心</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/数组/">数组</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/algorithm/2023/11/15/58.最后一个单词的长度/">58.最后一个单词的长度</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-11-15T00:00:00.000Z" itemprop="datePublished">2023年11月15日</time> · <!-- -->阅读需 2 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/Whilconn" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Whilconn</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1题干">1、题干<a href="#1题干" class="hash-link" aria-label="1、题干的直接链接" title="1、题干的直接链接">​</a></h2><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。</p><p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p> </p><p><strong>示例 1：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>s = &quot;Hello World&quot;<br><strong>输出：</strong>5<br><strong>解释：</strong>最后一个单词是“World”，长度为5。<br></code></pre><p><strong>示例 2：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>s = &quot;   fly me   to   the moon  &quot;<br><strong>输出：</strong>4<strong><br>解释：</strong>最后一个单词是“moon”，长度为4。<br></code></pre><p><strong>示例 3：</strong></p><pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><code class="codeBlockLines_e6Vv"><strong>输入：</strong>s = &quot;luffy is still joyboy&quot;<br><strong>输出：</strong>6<br><strong>解释：</strong>最后一个单词是长度为6的“joyboy”。<br></code></pre><p> </p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li><li><code>s</code> 仅有英文字母和空格 <code>&#x27; &#x27;</code> 组成</li><li><code>s</code> 中至少存在一个单词</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2思路">2、思路<a href="#2思路" class="hash-link" aria-label="2、思路的直接链接" title="2、思路的直接链接">​</a></h2><p>模拟</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3代码">3、代码<a href="#3代码" class="hash-link" aria-label="3、代码的直接链接" title="3、代码的直接链接">​</a></h2><div class="language-TypeScript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-TypeScript codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">function lengthOfLastWord(s: string): number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return s.split(&#x27; &#x27;).filter(Boolean).pop().length;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/algorithm/tags/字符串/">字符串</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--next" href="/algorithm/page/2/"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Whilconn. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.a1c0d390.js"></script>
<script src="/assets/js/main.a5467f83.js"></script>
</body>
</html>